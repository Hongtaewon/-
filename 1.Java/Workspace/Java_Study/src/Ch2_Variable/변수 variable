# 변수 variable
#decimal to binary
	10진수 : 0.625
	0.625 x 2 = 1.25
	0.25 x 2 = 0.5
	0.5 x 2 = 1
	소수부가 0이 될 때까지 반복한다.
	위의 숫자에서 정수부만 위에서 아래로 순서대로 적고 앞에 0.을 붙이면 된다.
	10진수 : 0.625 -> 2진수 : 0.101

#보수 (complement)
	n의 보수는 더했을 때 n이 되는 수를 말한다. 7의 10의 보수는 3이고, 3의 10의 보수는 7이다.
	3과 7은 '10의 보수의 관계에 있다'고 할 수 있다.
	2진수에서 2는 '10'이다. 2진수로 '10'은 자리올림이 발생하고 0이 되는 수를 뜻한다. 그래서 2의 보수 관계에 있는 두 2진수를 더하면 (자리올림이 발생하고)0이 된다.
	
	음수를 2진수로 표현하기
	10진수 : -5
	-5 ->(절대값) 5 ->(2진수) 101 ->(2의 보수) 1011
	
	@1의 보수를 구하는 법
		2진수에서 0->1, 1->0로 변환한다.
	@2의 보수를 구하는 법
		맨 앞에 0을 붙이고 10진수를 2진수로 변환 -> 2진수를 뒤집음 0->1, 1->0, 그리고 1을 더함.
		즉, 1의 보수 +1이다.

#부동소수점의 이해
	float  : S(1) + E(8) + M(23)  : 부호 + 지수 + 가수
	double : S(1) + E(11) + M(52) : 부호 + 지수 + 가수
	표현 : +-M x 2^E
	S(부호) : 0 or 1
	E(지수) : -2^(E-1)+1 ~ 2^(E-1) : 바이어스 표현법으로 사용된다. -127(00000000) ~ 128(11111111)
	M(가수) : 구하려는 숫자를 부동소수점으로 나타낸다. 19.25 -> 10011.01 -> 1.001101 x 2^4 -> 00110100000....
	
	※바이어스 표현법 = 2의 보수법 + 바이어스 상수
	ex) 127을 바이어스 표현법으로 나타낸다.
	127을 2의 보수법으로 0111 1111
	바이어스 상수 : 2^(n-1)-1 n: 비트부 자리수(여기서는 8bit)
	0111 1111 + 0111 1111 = 1111 1110
	float은 10진수로 7자리, double은 10진수로 15자리의 정밀도로 저장 가능
	
#형변환
	float -> int시 소수점 이하는 반올림이 아닌 버림이다.
	float -> double시 가수부분의 나머지를 0으로 채운다.
	double -> float에서 24번째 자리에서 반올림이 일어난다. 24번째 자리가 1인 경우, 23번 자리 값이 1 증가한다.
	float의 최대값보다 큰 값을 float으로 형변환하는 경우, +-0 또는 +-무한대의 결과를 얻는다.
	
	@정수형을 실수형으로 변환
	int -> float : ex) 7 -> 111 -> 1.11 x 2^(2+127)  ※127은 기저 129를 지수 부분에 입력하면 바이어스 표현법으로 입력된다.
						0(부호) 1000 0001(지수) 110000....(가수)
	@실수형을 정수형으로 변환
	float -> int : ex) 위의 7을 실수형으로 변환한 값을 가져와 1.11000..에 129-127=2만큼의 2의 승수를 곱하면 111이 된다. 나머지가 있다면 버린다.
						즉 1.11 x 2^2 => 111로 변환된다.
	@자동 형변환
	형변환을 명시하지 않았을 때, 기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환을 해준다.
	byte -> short -> int -> long -> float -> double
			char  ->
	오른쪽으로의 형변환은 명시하지 않아도 자동으로 변환되지만, 왼쪽으로의 형변환은 반드시 형변환 연산자를 써서 명시해야한다.
	왼쪽으로 형변환시 저장할 수 있는 값보다 큰 경우, 값이 손실된다.
	※ short과 char는 2byte로 가지는 크기는 같지만, 범위가 서로 다르기 때문에 형변환시 값이 손실될 수 있고, 자동 형변환도 불가능하다.